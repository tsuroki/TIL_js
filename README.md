# Java script# 흐름도 구상
## Object 객체 a
사용자가 컨트롤 할 수 있는 대상을 객체라 보른다.
ex) 버튼, 링크, 텍스트 박스 등

## Property 속성
객체가 가지는 속성
ex) 태그명, 클래스, 아이디, 색상, 위치 등

## Event 이벤트
인터넷 브라우저에서 발생할 수 있는 사건
ex) 클릭, 드래그, 더블클릭, 키보드 입력 등

## 실행 -ex.function(함수) Method(메소드/방법)
ex) 확인, 삭제, 취소, 이동, 애니메이션 등
* 클래스 내부에 선언된 함수는 메소드라 부르며 클래스와 연관이 없다면 일반적으로 함수라고 부른다.

---

ex) <button type="button" id="btn" onclick="prompt()"></button>
이런게 있다고 치면
button은 객체가 되고
그에 따르는 type, id는 속성이 된다.
그리고 onclick은 이벤트가 되고
prompt는 함수가 된다.

생각을 해보자.
1. onclick="prompt()"는 onlick이라는 이벤트가 있고 prompt라는 함수가 있다.
이걸 html에서 알려주지 않은데에는, 함수라는 특성 때문일 것.
2. 그러나 a의 target="_blank"는 알려주었고, target은 함수가 아니며
black또한 함수가 아니다.

즉 이벤트는 사람이 어떠한 동작을 시행했을 때를 말한다.
사람이 어떠한 동작을 통해서 "이걸 하고싶다" 라고 할 때 또는 선언할 때
이벤트는 사용자가 원하는 동작을 작동하기 위해서 이것을 한다고 설정하는 값이고.
함수는 거기에 맞추어 발동하는 것이라고 생각하자.

target="_blank"는 사람이 클릭을 함으로 써 새로운 창으로 열리게 설정을 넣은 것이고, prompt는 클릭을 함으로 써 해당 값을 실행하는 것이니 기계적인 과정을 담은 값.

그렇다면

이벤트는 사람이 원하는 결과에 도달하기 위해 취하는 행동이고
함수는 거기에 도달하기 위해 진행해야 하는 과정을 실행하여 을 함축하여 담은 것이다.

---

# 자바스크립트 작성방법
* 내부 스크립트
    <Script> 스크립트 작성 </script>

* 외부 스크립트
    <Script src="경로"></script>

* 인라인 스크립트(이벤트한정)
    <tag event="이벤트함수"></tag>

    /* 여러 줄 주석 */
    // 한 줄 주석

## async와 defer 차이점

* 외부 스크립트
    1) <script src="경로" async></script>
    2) <script src="경로" defer></script>

async = 페이지 로드 !관계없이! 다운로드 후 즉시 실행 스크립트
defer = 페이지 로드가 !완료된 후! 즉시 실행 스크립트
외부 스크립트 시에만 사용이 가능하다.
그리고 CSS 이후에 script가 들어가야 한다.

CSS는 페이지를 구성하는 것 중 하나이므로 페이지 로드가 끝나고 실행되야 에러나 나타나지 않기 때문에 css 뒤에 script를 넣고 defer를 넣어야 한다.

---

코드의 빠른 실행 결과를 확인할 수 있고
디버깅을 할 수 있는 콘솔 기능을 적극 활용.
about:blank
F12또는 Ctrl + shift + i

---

변수 부여
var a; /* undefined 값이 정의되지 않음 */
a = b; /* 최종값 20 */
var b=10;
a=20; //값이 정의 됨
var c1; /* undefined 값이 정의되지 않음 */
c1 = 30; /* 30 정의 */
c1 = 40; /* 기존 정의된 30 제거 , 40 새로 정의 */
c1 = b; /* 또 기존 정의된 40 제거, b와 같은 값을 대입함. 10 */

---

변수 표기법 종류
1. 카멜 기법
ex) newName, webSiteCode

2. 파스칼 표기법
ex) NewName, WebSiteCode

3. 밑줄 표기법
ex) new_name, website_code

---
## 자바스크립트 예제
* 변수 OX

var 1num=10; X (숫자)
var $num=10; 속성이라 O
var 100num=10; X(숫자)
var num100=10; 가능
var test=10; 가능
var num=10;가능
var str="hello" 가능
var my name;No 
var _name (밑줄 표기)
var if; No

---
객체.속성과 객체.함수 구분법 / 뒤의 ()가 있는지 없는지 체크
1. 객체.속성
2. 객체.함수();<!-- 괄호 존재 -->

---

문자열 연결 연산자 (+)
* 문자열(string)을 서로 이어붙이는데 사용하는 연산자
* 피연산자 중 하나라도 '문자' 일 경우 연결 연산자로 인식

ex) let greeting='안녕'+'봄!'

콤마(,)
* 연산자처럼 결과를 반한하지 않는 단순한 구분자(separator)로 사용하는 역할
ex) console.log(greeting,'잘가!')

---

# null
* 값이 비어있음, 존재하지 않음
* 사용자에 의해 결정되는 의도적인 대입 값

# undefined
* 정의(할당) 되지 않음.
* undefined는 변수를 초기화 하지않은 오류 상태이다.
* undefined는 변수에 대인해선 안된다.
* 사용자가 실수로 초기화하지 않은 변수에 들어간 일종의 오류값.

---

# es6 템플릿 문자열
백틱기호 `로 문자열+식 전체를 묶고 ${}로 프로그래밍 식을 작성하는 기법

1) 템플릿 문자열 적용 전 before
'1+1은'+(1+1)+'입니다.'

2) 템플릿 문자열 적용 후 after
`1+1은 1(1+1) 입니다`

---

# 변수 스코프(데이터 접근 가능 위치)

### 스코프(scope) 개념 정리
스코프란 변수값이 접근할 수 있는 위치
1) 전역 스코프 : 코드 어느곳에나 접근 가능
2) 지역 스코프 : 선언된 블록 내부만 접근 가능

지역 스코프는 지역 변수, 전역 스코프는 전역 변수라고도 부른다.

### 그럼 블록이 뭔데?
함수, 루프 등 {}로 구분되는 영역을 블록이라 부르며, 이곳이 곧 지역이다.

---

# 변수

## 변수 var
* var 생성 변수명
* 전역 스코프 선언 방식!
* 중복 선언이 가능하다.

## 변수 let
* let 생성 변수명
* var 선언 키워드와 유사하나, 중복 선언이 불가하다.
* 블록 스코프 선언 방식.

## 상수 const
* const 생성 변수명
* 변경되지 않는 상수로 최초 선언 후 값 변경 불가.
* 고정된 변수 데이터에만 const 선언 가능
* 블록 스코프 선언 방식.

---

#자바스크립트 기초함수
## log() 기록 실행 함수
## typeof() 데이터 타입 실행함수
## print() 출력함수
## prompt() 질문 답변 함수.
## confirm() 확인 취소창 실행

---

# 25.09.10

### 변수 OX
1.
### 기초 개념 및 속성, 함수 종류
* `var 변수명` : 수정 가능한 전역 변수
* `let 변수명` : 수정 가능한 전역/지역 변수
* `const 변수명=대입값` : 수정 불가능한 상수 (전역/지역 변수)
* **객체.속성** (O)
* **객체.속성.속성** (O)
* **객체.객체.속성** (X) / No grouping
* **객체.함수**
* **객체.속성.함수**
* **객체.함수.속성**
* 자주 이용하는 기본 속성 : '객체명.length'
* 자주 이용하는 기본 함수 : '객체명.toLocaleString(국가코드)', `typeof()`
* 공부용 기초 함수 : `prompt()`, `confirm()`

---

# 자바스크립트 내부 메모리 구조
Call Stack(콜스택) / Memory Heap (메모리 힙)
1. Call Stack(콜 스택)
원시형 데이터를 가진 변수가 저장되는 메모리 (공간) /  ex) 택배 송장 주소

2. 메모리 힙
오브젝트형(객체형) 변수 생성시 데이터가 저장되는 참조형 공간(메모리) / ex) 택배 물건
값이 크거나, 복잡한 참조형 데이터는 "힙" 이란 메모리 공간에 저장된다.

## 오브젝트형 데이터
한 가지의 데이터가 아니라, 데이터 컬렉션과 같은 여러 자료형을 표현할 수 있는 특수한 자료형.
배열과 객체등도 오브젝트에 해당한다.

## 원시형
원시형 -> 특정 변수에 값을 복사하는 방식. (Call by value) -> 콜 바이 밸류
ex) let age = 100; / 변수 생성, 변수 및 값 특정
특정 변수에 지정된 값 자체를 콜 스택에 저장.

오브젝트형 -> 특정 변수에 메모리 복사 방식
ex) let info ={name:'가을'}
이러면 info라는 변수가 callstack에 저장되는데,
여기서 info에 지정된, '가을'이라는 참조 값인 {name:'가을'}이 메모리 힙에 저장된다.

오브젝트형은 특정 변수에 지정된 메모리 주소를 복사한다.
이때 콜 스택은
0*(16진수)값으로 저장하는데,
0*2000 -> 주소 2000번지 뜻 (주소값을 이용한 간접적 접근)
이렇게 뒤에 붙는 16진수 값을 주소값으로 칭하여 접근한다.

그렇다면 여기서 heap은 데이터 사용시 이용하는 메모리 방식이다.

---

# 객체

## 객체의 정의
* 이름과 값을 한쌍으로 묶은 데이터를 뜻한다. (연관 배열 또는 사전)
* 객체명={객체속성 : 객체값, 객체속성 : 객체값} // 객체 생성
* 객체명.속성; // 객체값 호출

ex)
var cardGame_v1 = new Object();
CardGame_vl{
    name:rank;
    value : 'A,K,Q,J,10'
}
CardGame_v1.name;
CardGame_v1.value;

ex)
var cardGame_v2 = {
    name:rank;
    value : 'A,K,Q,J,10'
}

CardGame_v2.name;
CardGame_v2.value;

---

그렇담 객체는 어떻게 적용하나?

객체명={객체속성 : 객체값, 객체속성 : 객체값}

* 도형의 정보 저장 (너비, 높이, 좌표, 모서리 모양, 색상 등)
* 회원 정보 저장 (이름, 나이, 성별, 지역 등)
* 쇼핑몰 상품 저장 (상품명, 상품가격, 상품 재고수량, 상품 색상 등)
* 영화관 좌석 지정 (좌석명, 좌석위치, 좌석가격 등)

---

# 배열(Array)
* 여러 개의 값(데이터)을 순서대로 저장할 수 있는 자료 구조 (복수 데이터 저장)
* [] 대괄호를 사용해서 각 데이터를 저장한다.
* 각 개별값은 index(인덱스)로 접근하며, 개별 인덱스 값은 0부터 인식한다.
* 개별 인덱스 데이터의 whole length(전체길이)는 1부터 취급한다.

## 배열 생성과 호출
* let 변수명=[]; -> 대괄호를 사용한 배열 생성
* let 변수명 = new Array(index0, index1, index2, ...)
* let 변수명 = new Array(3) -> 전체길이 3개를 가진 배열 생성

[] = new array()로 치환이 가능하나, []에는 전체길이 부여가 불가능하며, new array()에는 전체길이 부여가 가능하다.

### 기초 함수
* 자주 이용하는 기본 속성 : '객체명.length'
* 자주 이용하는 기본 함수 : '객체명.toLocaleString(국가코드)', `typeof()`
* 공부용 기초 함수 : `prompt()`, `confirm()`
### 배열관리 함수
* '객체.push()' : 배열의 끝 위치에 값 추가
* '객체. pop()' : 배열의 끝 위치에서 값 1개 제거
* '객체. unshift()' : 배열의 시작위치에 값 추가
* '객체. shift()' : 배열의 시작위치에서 값 제거

---
# 연산자

표현식 -> 변수, 함수 등 값을 바탕을 계산하는 행위
연산자 -> 표현식들을 조합해 복잡한 표현식을 만드는 행위
비연산자 -> 연산을 수행하는 대상.
1) 단항 연산자 -> 피연산자 1개인경우.

2) 이항 연산자 -> 피연산자가 2개일 경우

3) 삼항 연산자 -> 특정 조건에 맞춰 연산을 실행하는 경우.
ex) 조건? x:

## 산술 연산자.
우리가 아는 수학식.
** 거듭제곱. 왼쪽의 피 연산자의 오른쪽 피 연산자의 값 만큼 곱한 값.
** 나머지 연산자 (%) 7&3 -> 1
ex) a**b

### 연결 및 더하기 연산자(+)
숫자+숫자  -> 더하기 연산자
숫자 + 문자 -> 연결연산자
문자 + 문자 -> 연결연산자

더하기 연산자 -> 결과값이 number일 경우
연결연산자 -> 결과값이 string일 경우.

### -, *, /의 특별 기능

* -> 문자열*숫자 -> 문자를 숫자로 자동 현변환하여 결과값 처리.
* 1/7 -> 숫자로 인식 후 결과로 처리.
* (1+7) * "2" ->본래 " "일 경우 문자열로 처리하나, 자동 변환해 2로 인식.

ex) (1+7) * "two" = NaN
-> "two" 우리가 흔히 아는 two는 2라고 하지만, 여기서는 two는 문자열로, 숫자열로 형변환이 안되기 때문에 NaN이 나타난다.

# 산술 단항 연산자 - 증감 연산자

++a : a를 1을 증가 시킨후 a연산 진행
a++ : a연산 진행 후 1 증가
++는 어떠한 연산 전 후에 1을 증가 시키는 역할
--a : 1 감소 후 a연산 진행
a-- : a연산 진행 후 1 감소
 * 연산자 뒤 데이터 종류는 반드시 Number여야 할것.

# 복합 대입 연산자

+= -> ex) a += b -> a= a+b /기존 a값에 b를 더하여 a에 대입
-= -> ex) a -= b -> a= a-b /기존 a값에 b를 빼서 a에 대입
*= -> ex) a *= b -> a= a*b /기존 a값에 b를 곱해서 a에 대입
/= -> ex) a /= b -> a= a/b /기존 a값에 b를 나눠서 a에 대입
%= -> ex) a %= b -> a= a%b /기존 a값에 b를 나눠서 나온 나머지 값을 a에 대입

# 함수 {올게왔다 ㅅㅂ}
* 반복적인 프로그래밍 기능을 가지는 것. (강조 : 반복적인 프로그래밍 -> 반복적으로 사용하는 명령어나 로직이 있다.)
**함수는 일반 사용자에겐 블랙박스와 같다.**

## 함수로 인해 생기는 장점들
* 코드 가독성 향상
* 유지보수 및 확장 유리
* (스파게티 코드)꼬인 코드 및 중복 코드 감소

# 알고리즘
* 컴퓨터가 수행하는 계산식을 말한다.
* 주요 특성으로 "반복" 이 있다.

ex) 헨젤과 그레텔
헨젤과 그레텔이 떨어뜨렸던 돌 -> 내가 왔던 길을 표시했다. -> 돌아가는 길에 대한 데이터가 된다.
그렇담 그 데이터는 1회용인가? -> 다회용으로 써야하므로 회수한다.

! function 함수명() {재사용문법} !

ex) 헨젤과 그레텔
! functino 집찾기함수() {
    조약돌 준비
    계모와 함께 숲속으로 이동
    일정 간격(몇마다?)으로 도약돌을 바닥에 떨어뜨린다.
    계모가 떠난다.
    끝 지점에서 시작하여
    조약돌이 떨어진 가까운 좌표로 이동한다.
    조약돌에 도달하였을 때 조약돌을 회수한다.
    회수한 조약돌을 가진다.
    회수한 조약돌이 본래 준비한 갯수와 맞을 때
    집으로 돌아간다.
} !

### 함수의 종류
1. 내장 함수
* 자바 스크립트에서 이미 정의된 함수로 alert(), prompt() 등이 있다.

2. 사용자 지정 함수
* 개발자가 내장함수가 아닌 자신이 원하는 기능을 직접 작성하여 만들 때 사용한다.

ex) function 함수명(전달인자){
    함수실행내용
}
* functon -> 함수선언
* 함수 이름 -> 함수 이름 지정
* 전달 인자 -> 매개변수, 인수 등 여러가지 용어 사용. 함수내 데이터를 전달하는 변수명.
            전달 데이터가 많을 경우, 객체 타입으로 전달.
* 중괄호 {} -> 함수 영역의 시작과 끝을 나타내며, 내부에 함수 반복실행 내용 작성.

### 함수 스코프(데이터 접근 가능 위치)
지역 스코프(집고양이), 전역스코프(길고양이)

전역 스코프 -> 변수는 코드 어느곳에나 접근가능
블록 스코프 -> 변수가 선언된 블록 내부에만 접근 가능

**블록영역**
함수, 루프 등 {중괄호}로 구분되는 영역 / 즉, 블록 안에 선언된 스코프는 내부에서만 쓸 수 있다.(slang 같은 느낌)

---

# 전달인자
매개변수 또는 인수를 사용한 용어. 함수 내 데이터를 전달하는 변수명.
-> 반복되는 명령어에 데이터를 전달. 전달할 데이터가 많을 땐 객체 타입으로 전달.

## 매개변수
함수 알고리즘이 실행될 때 알고리즘 내 일부 데이터를 수정할 수 있는 데이터.
매개변수는 **지역변수**로 처리됨.
매개변수를 잘 활용해야 함수의 효율성이 향상되며
매개변수 생성과 동시에 기본값 설정이 가능하다. <!-- 매개변수 = 기본값 대입. -->

ex) function 함수명(매개변수명){return실행}
함수명(매개변수)
-> 먼저 생성된 함수명이라는 용병의 이름을 수배하여 함수명을 호출, 이 때 매개변수라는 값을 지불하여 함수가 수행하는 알고리즘을 수행하게 된다.

---

# 함수의 반환 결과

## 함수의 리턴 값
* 리턴한다 -> 결과를 되돌려준다.
* 함수 내에서 결과값을 리턴하면, 함수 외부에서 리턴값을 받아 출력할 수 있다.
return number;
* 리턴 뒤 아무값도 입력하지 않으면 값을 돌려주는 뜻이 아닌 **함수를 종료한다는 의미를 갖는다.**

function 함수명(매개변수){
    함수 종료 후 return(종료) 실행
}
함수명(매개변수)

## 익명함수 / 변수 내 function 키워드를 지정해 생성하는 함수이기도 하다.
여러번 임의로 호출하는 일반적 함수와 다르게
이벤트 방생시 호출하는 **일회용 함수.**

식
function nickName() {} 일반 함수
let 함수이름 function() {} 익명 함수

---

## 화살표 함수
ES6에서 도입된 간결한 함수 표현식.
const add =(매개변수) => {returna a+b;}
console.log(add(2,3))

매개변수가 1개일 경우 괄호 생략이 가능하다. 하지만 값이 추가될 수 있으므로 쓰는걸 추천한다.
const add = name => {returna a+b;}
console.log(name)