# Java script# 흐름도 구상
## Object 객체 a
사용자가 컨트롤 할 수 있는 대상을 객체라 보른다.
ex) 버튼, 링크, 텍스트 박스 등

## Property 속성
객체가 가지는 속성
ex) 태그명, 클래스, 아이디, 색상, 위치 등

## Event 이벤트
인터넷 브라우저에서 발생할 수 있는 사건
ex) 클릭, 드래그, 더블클릭, 키보드 입력 등

## 실행 -ex.function(함수) Method(메소드/방법)
ex) 확인, 삭제, 취소, 이동, 애니메이션 등
* 클래스 내부에 선언된 함수는 메소드라 부르며 클래스와 연관이 없다면 일반적으로 함수라고 부른다.

---

ex) <button type="button" id="btn" onclick="prompt()"></button>
이런게 있다고 치면
button은 객체가 되고
그에 따르는 type, id는 속성이 된다.
그리고 onclick은 이벤트가 되고
prompt는 함수가 된다.

생각을 해보자.
1. onclick="prompt()"는 onlick이라는 이벤트가 있고 prompt라는 함수가 있다.
이걸 html에서 알려주지 않은데에는, 함수라는 특성 때문일 것.
2. 그러나 a의 target="_blank"는 알려주었고, target은 함수가 아니며
black또한 함수가 아니다.

즉 이벤트는 사람이 어떠한 동작을 시행했을 때를 말한다.
사람이 어떠한 동작을 통해서 "이걸 하고싶다" 라고 할 때 또는 선언할 때
이벤트는 사용자가 원하는 동작을 작동하기 위해서 이것을 한다고 설정하는 값이고.
함수는 거기에 맞추어 발동하는 것이라고 생각하자.

target="_blank"는 사람이 클릭을 함으로 써 새로운 창으로 열리게 설정을 넣은 것이고, prompt는 클릭을 함으로 써 해당 값을 실행하는 것이니 기계적인 과정을 담은 값.

그렇다면

이벤트는 사람이 원하는 결과에 도달하기 위해 취하는 행동이고
함수는 거기에 도달하기 위해 진행해야 하는 과정을 실행하여 을 함축하여 담은 것이다.

---

# 자바스크립트 작성방법
* 내부 스크립트
    <Script> 스크립트 작성 </script>

* 외부 스크립트
    <Script src="경로"></script>

* 인라인 스크립트(이벤트한정)
    <tag event="이벤트함수"></tag>

    /* 여러 줄 주석 */
    // 한 줄 주석

## async와 defer 차이점

* 외부 스크립트
    1) <script src="경로" async></script>
    2) <script src="경로" defer></script>

async = 페이지 로드 !관계없이! 다운로드 후 즉시 실행 스크립트
defer = 페이지 로드가 !완료된 후! 즉시 실행 스크립트
외부 스크립트 시에만 사용이 가능하다.
그리고 CSS 이후에 script가 들어가야 한다.

CSS는 페이지를 구성하는 것 중 하나이므로 페이지 로드가 끝나고 실행되야 에러나 나타나지 않기 때문에 css 뒤에 script를 넣고 defer를 넣어야 한다.

---

코드의 빠른 실행 결과를 확인할 수 있고
디버깅을 할 수 있는 콘솔 기능을 적극 활용.
about:blank
F12또는 Ctrl + shift + i

---

변수 부여
var a; /* undefined 값이 정의되지 않음 */
a = b; /* 최종값 20 */
var b=10;
a=20; //값이 정의 됨
var c1; /* undefined 값이 정의되지 않음 */
c1 = 30; /* 30 정의 */
c1 = 40; /* 기존 정의된 30 제거 , 40 새로 정의 */
c1 = b; /* 또 기존 정의된 40 제거, b와 같은 값을 대입함. 10 */

---

변수 표기법 종류
1. 카멜 기법
ex) newName, webSiteCode

2. 파스칼 표기법
ex) NewName, WebSiteCode

3. 밑줄 표기법
ex) new_name, website_code

---
## 자바스크립트 예제
* 변수 OX

var 1num=10; X (숫자)
var $num=10; 속성이라 O
var 100num=10; X(숫자)
var num100=10; 가능
var test=10; 가능
var num=10;가능
var str="hello" 가능
var my name;No 
var _name (밑줄 표기)
var if; No

---
객체.속성과 객체.함수 구분법 / 뒤의 ()가 있는지 없는지 체크
1. 객체.속성
2. 객체.함수();<!-- 괄호 존재 -->

---

문자열 연결 연산자 (+)
* 문자열(string)을 서로 이어붙이는데 사용하는 연산자
* 피연산자 중 하나라도 '문자' 일 경우 연결 연산자로 인식

ex) let greeting='안녕'+'봄!'

콤마(,)
* 연산자처럼 결과를 반한하지 않는 단순한 구분자(separator)로 사용하는 역할
ex) console.log(greeting,'잘가!')

---

# null
* 값이 비어있음, 존재하지 않음
* 사용자에 의해 결정되는 의도적인 대입 값

# undefined
* 정의(할당) 되지 않음.
* undefined는 변수를 초기화 하지않은 오류 상태이다.
* undefined는 변수에 대인해선 안된다.
* 사용자가 실수로 초기화하지 않은 변수에 들어간 일종의 오류값.

---

# es6 템플릿 문자열
백틱기호 `로 문자열+식 전체를 묶고 ${}로 프로그래밍 식을 작성하는 기법

1) 템플릿 문자열 적용 전 before
'1+1은'+(1+1)+'입니다.'

2) 템플릿 문자열 적용 후 after
`1+1은 1(1+1) 입니다`

---

# 변수 스코프(데이터 접근 가능 위치)

### 스코프(scope) 개념 정리
스코프란 변수값이 접근할 수 있는 위치
1) 전역 스코프 : 코드 어느곳에나 접근 가능
2) 지역 스코프 : 선언된 블록 내부만 접근 가능

지역 스코프는 지역 변수, 전역 스코프는 전역 변수라고도 부른다.

### 그럼 블록이 뭔데?
함수, 루프 등 {}로 구분되는 영역을 블록이라 부르며, 이곳이 곧 지역이다.

---

# 변수

## 변수 var
* var 생성 변수명
* 전역 스코프 선언 방식!
* 중복 선언이 가능하다.

## 변수 let
* let 생성 변수명
* var 선언 키워드와 유사하나, 중복 선언이 불가하다.
* 블록 스코프 선언 방식.

## 상수 const
* const 생성 변수명
* 변경되지 않는 상수로 최초 선언 후 값 변경 불가.
* 고정된 변수 데이터에만 const 선언 가능
* 블록 스코프 선언 방식.

---

#자바스크립트 기초함수
## log() 기록 실행 함수
## typeof() 데이터 타입 실행함수
## print() 출력함수
## prompt() 질문 답변 함수.
## confirm() 확인 취소창 실행

---

# 25.09.10

### 변수 OX
1.
### 기초 개념 및 속성, 함수 종류
* `var 변수명` : 수정 가능한 전역 변수
* `let 변수명` : 수정 가능한 전역/지역 변수
* `const 변수명=대입값` : 수정 불가능한 상수 (전역/지역 변수)
* **객체.속성** (O)
* **객체.속성.속성** (O)
* **객체.객체.속성** (X) / No grouping
* **객체.함수**
* **객체.속성.함수**
* **객체.함수.속성**
* 자주 이용하는 기본 속성 : '객체명.length'
* 자주 이용하는 기본 함수 : '객체명.toLocaleString(국가코드)', `typeof()`
* 공부용 기초 함수 : `prompt()`, `confirm()`

---

# 자바스크립트 내부 메모리 구조
Call Stack(콜스택) / Memory Heap (메모리 힙)
1. Call Stack(콜 스택)
원시형 데이터를 가진 변수가 저장되는 메모리 (공간) /  ex) 택배 송장 주소

2. 메모리 힙
오브젝트형(객체형) 변수 생성시 데이터가 저장되는 참조형 공간(메모리) / ex) 택배 물건
값이 크거나, 복잡한 참조형 데이터는 "힙" 이란 메모리 공간에 저장된다.

## 오브젝트형 데이터
한 가지의 데이터가 아니라, 데이터 컬렉션과 같은 여러 자료형을 표현할 수 있는 특수한 자료형.
배열과 객체등도 오브젝트에 해당한다.

## 원시형
원시형 -> 특정 변수에 값을 복사하는 방식. (Call by value) -> 콜 바이 밸류
ex) let age = 100; / 변수 생성, 변수 및 값 특정
특정 변수에 지정된 값 자체를 콜 스택에 저장.

오브젝트형 -> 특정 변수에 메모리 복사 방식
ex) let info ={name:'가을'}
이러면 info라는 변수가 callstack에 저장되는데,
여기서 info에 지정된, '가을'이라는 참조 값인 {name:'가을'}이 메모리 힙에 저장된다.

오브젝트형은 특정 변수에 지정된 메모리 주소를 복사한다.
이때 콜 스택은
0*(16진수)값으로 저장하는데,
0*2000 -> 주소 2000번지 뜻 (주소값을 이용한 간접적 접근)
이렇게 뒤에 붙는 16진수 값을 주소값으로 칭하여 접근한다.

그렇다면 여기서 heap은 데이터 사용시 이용하는 메모리 방식이다.

---

# 객체

## 객체의 정의
* 이름과 값을 한쌍으로 묶은 데이터를 뜻한다. (연관 배열 또는 사전)
* 객체명={객체속성 : 객체값, 객체속성 : 객체값} // 객체 생성
* 객체명.속성; // 객체값 호출

ex)
var cardGame_v1 = new Object();
CardGame_vl{
    name:rank;
    value : 'A,K,Q,J,10'
}
CardGame_v1.name;
CardGame_v1.value;

ex)
var cardGame_v2 = {
    name:rank;
    value : 'A,K,Q,J,10'
}

CardGame_v2.name;
CardGame_v2.value;

---

그렇담 객체는 어떻게 적용하나?

객체명={객체속성 : 객체값, 객체속성 : 객체값}

* 도형의 정보 저장 (너비, 높이, 좌표, 모서리 모양, 색상 등)
* 회원 정보 저장 (이름, 나이, 성별, 지역 등)
* 쇼핑몰 상품 저장 (상품명, 상품가격, 상품 재고수량, 상품 색상 등)
* 영화관 좌석 지정 (좌석명, 좌석위치, 좌석가격 등)

---

# 배열(Array)
* 여러 개의 값(데이터)을 순서대로 저장할 수 있는 자료 구조 (복수 데이터 저장)
* [] 대괄호를 사용해서 각 데이터를 저장한다.
* 각 개별값은 index(인덱스)로 접근하며, 개별 인덱스 값은 0부터 인식한다.
* 개별 인덱스 데이터의 whole length(전체길이)는 1부터 취급한다.

## 배열 생성과 호출
* let 변수명=[]; -> 대괄호를 사용한 배열 생성
* let 변수명 = new Array(index0, index1, index2, ...)
* let 변수명 = new Array(3) -> 전체길이 3개를 가진 배열 생성

[] = new array()로 치환이 가능하나, []에는 전체길이 부여가 불가능하며, new array()에는 전체길이 부여가 가능하다.

### 기초 함수
* 자주 이용하는 기본 속성 : '객체명.length'
* 자주 이용하는 기본 함수 : '객체명.toLocaleString(국가코드)', `typeof()`
* 공부용 기초 함수 : `prompt()`, `confirm()`
### 배열관리 함수
* '객체.push()' : 배열의 끝 위치에 값 추가
* '객체. pop()' : 배열의 끝 위치에서 값 1개 제거
* '객체. unshift()' : 배열의 시작위치에 값 추가
* '객체. shift()' : 배열의 시작위치에서 값 제거

---
# 연산자

표현식 -> 변수, 함수 등 값을 바탕을 계산하는 행위
연산자 -> 표현식들을 조합해 복잡한 표현식을 만드는 행위
비연산자 -> 연산을 수행하는 대상.
1) 단항 연산자 -> 피연산자 1개인경우.

2) 이항 연산자 -> 피연산자가 2개일 경우

3) 삼항 연산자 -> 특정 조건에 맞춰 연산을 실행하는 경우.
ex) 조건? x:

## 산술 연산자.
우리가 아는 수학식.
** 거듭제곱. 왼쪽의 피 연산자의 오른쪽 피 연산자의 값 만큼 곱한 값.
** 나머지 연산자 (%) 7&3 -> 1
ex) a**b

### 연결 및 더하기 연산자(+)
숫자+숫자  -> 더하기 연산자
숫자 + 문자 -> 연결연산자
문자 + 문자 -> 연결연산자

더하기 연산자 -> 결과값이 number일 경우
연결연산자 -> 결과값이 string일 경우.

### -, *, /의 특별 기능

* -> 문자열*숫자 -> 문자를 숫자로 자동 현변환하여 결과값 처리.
* 1/7 -> 숫자로 인식 후 결과로 처리.
* (1+7) * "2" ->본래 " "일 경우 문자열로 처리하나, 자동 변환해 2로 인식.

ex) (1+7) * "two" = NaN
-> "two" 우리가 흔히 아는 two는 2라고 하지만, 여기서는 two는 문자열로, 숫자열로 형변환이 안되기 때문에 NaN이 나타난다.

# 산술 단항 연산자 - 증감 연산자

++a : a를 1을 증가 시킨후 a연산 진행
a++ : a연산 진행 후 1 증가
++는 어떠한 연산 전 후에 1을 증가 시키는 역할
--a : 1 감소 후 a연산 진행
a-- : a연산 진행 후 1 감소
 * 연산자 뒤 데이터 종류는 반드시 Number여야 할것.

# 복합 대입 연산자

+= -> ex) a += b -> a= a+b /기존 a값에 b를 더하여 a에 대입
-= -> ex) a -= b -> a= a-b /기존 a값에 b를 빼서 a에 대입
*= -> ex) a *= b -> a= a*b /기존 a값에 b를 곱해서 a에 대입
/= -> ex) a /= b -> a= a/b /기존 a값에 b를 나눠서 a에 대입
%= -> ex) a %= b -> a= a%b /기존 a값에 b를 나눠서 나온 나머지 값을 a에 대입

# 함수 {올게왔다 ㅅㅂ}
* 반복적인 프로그래밍 기능을 가지는 것. (강조 : 반복적인 프로그래밍 -> 반복적으로 사용하는 명령어나 로직이 있다.)
**함수는 일반 사용자에겐 블랙박스와 같다.**

## 함수로 인해 생기는 장점들
* 코드 가독성 향상
* 유지보수 및 확장 유리
* (스파게티 코드)꼬인 코드 및 중복 코드 감소

# 알고리즘
* 컴퓨터가 수행하는 계산식을 말한다.
* 주요 특성으로 "반복" 이 있다.

ex) 헨젤과 그레텔
헨젤과 그레텔이 떨어뜨렸던 돌 -> 내가 왔던 길을 표시했다. -> 돌아가는 길에 대한 데이터가 된다.
그렇담 그 데이터는 1회용인가? -> 다회용으로 써야하므로 회수한다.

! function 함수명() {재사용문법} !

ex) 헨젤과 그레텔
! functino 집찾기함수() {
    조약돌 준비
    계모와 함께 숲속으로 이동
    일정 간격(몇마다?)으로 도약돌을 바닥에 떨어뜨린다.
    계모가 떠난다.
    끝 지점에서 시작하여
    조약돌이 떨어진 가까운 좌표로 이동한다.
    조약돌에 도달하였을 때 조약돌을 회수한다.
    회수한 조약돌을 가진다.
    회수한 조약돌이 본래 준비한 갯수와 맞을 때
    집으로 돌아간다.
} !

### 함수의 종류
1. 내장 함수
* 자바 스크립트에서 이미 정의된 함수로 alert(), prompt() 등이 있다.

2. 사용자 지정 함수
* 개발자가 내장함수가 아닌 자신이 원하는 기능을 직접 작성하여 만들 때 사용한다.

ex) function 함수명(전달인자){
    함수실행내용
}
* functon -> 함수선언
* 함수 이름 -> 함수 이름 지정
* 전달 인자 -> 매개변수, 인수 등 여러가지 용어 사용. 함수내 데이터를 전달하는 변수명.
            전달 데이터가 많을 경우, 객체 타입으로 전달.
* 중괄호 {} -> 함수 영역의 시작과 끝을 나타내며, 내부에 함수 반복실행 내용 작성.

### 함수 스코프(데이터 접근 가능 위치)
지역 스코프(집고양이), 전역스코프(길고양이)

전역 스코프 -> 변수는 코드 어느곳에나 접근가능
블록 스코프 -> 변수가 선언된 블록 내부에만 접근 가능

**블록영역**
함수, 루프 등 {중괄호}로 구분되는 영역 / 즉, 블록 안에 선언된 스코프는 내부에서만 쓸 수 있다.(slang 같은 느낌)

---

# 전달인자
매개변수 또는 인수를 사용한 용어. 함수 내 데이터를 전달하는 변수명.
-> 반복되는 명령어에 데이터를 전달. 전달할 데이터가 많을 땐 객체 타입으로 전달.

## 매개변수
함수 알고리즘이 실행될 때 알고리즘 내 일부 데이터를 수정할 수 있는 데이터.
매개변수는 **지역변수**로 처리됨.
매개변수를 잘 활용해야 함수의 효율성이 향상되며
매개변수 생성과 동시에 기본값 설정이 가능하다. <!-- 매개변수 = 기본값 대입. -->

ex) function 함수명(매개변수명){return실행}
함수명(매개변수)
-> 먼저 생성된 함수명이라는 용병의 이름을 수배하여 함수명을 호출, 이 때 매개변수라는 값을 지불하여 함수가 수행하는 알고리즘을 수행하게 된다.

---

# 함수의 반환 결과

## 함수의 리턴 값
* 리턴한다 -> 결과를 되돌려준다.
* 함수 내에서 결과값을 리턴하면, 함수 외부에서 리턴값을 받아 출력할 수 있다.
return number;
* 리턴 뒤 아무값도 입력하지 않으면 값을 돌려주는 뜻이 아닌 **함수를 종료한다는 의미를 갖는다.**

function 함수명(매개변수){
    함수 종료 후 return(종료) 실행
}
함수명(매개변수)

## 익명함수 / 변수 내 function 키워드를 지정해 생성하는 함수이기도 하다.
여러번 임의로 호출하는 일반적 함수와 다르게
이벤트 방생시 호출하는 **일회용 함수.**

식
function nickName() {} 일반 함수
let 함수이름 function() {} 익명 함수

---

## 화살표 함수
ES6에서 도입된 간결한 함수 표현식.
const add =(매개변수) => {returna a+b;}
console.log(add(2,3))

매개변수가 1개일 경우 괄호 생략이 가능하다. 하지만 값이 추가될 수 있으므로 쓰는걸 추천한다.
const add = name => {returna a+b;}
console.log(name)

---
# WINDOW 객체
## BOM (browser object model)
windowsms BOM의 최상위 경로

##BOM 함수 종류
window.alert
window.prompt()
window.confirm()
window.location.href; ( )
window.location.href="값"

window.print()
window.document.write()
window.open()
window.pen(ul 등)

---

DOM document object Model -> 돔 트리
DOM  트리를 구성하는 노드.

getElementsByTagName -> 지정된 태그 이름을 가진 **모든 HTML** 요소를 찾아 HTML 노드로 반환
getElementsByClassName -> 클래스 이름을 가슨 모든 HTML 요소를 찾아 HTML노드로 반환
getElementsById -> 다른 getElements와 달리, id는 중복 요소가 없기 때문에 index슬롯을 지정하지 않아도 된다. 그러나 변수명 충돌, 그리고 유지보수 면에서 어려움을 겪을 수 있으므로 실무에선 변수 선언이 필요하다.

querySelector -> 지정된아이디, 클래스, 태그 이름을 가진 첫번째 HTML요소를 찾아 HTML 요소로 전환.

querySelectorAll -> 지정된아이디, 클래스, 태그 이름을 가진 모든 HTML요소를 찾아 인덱스와 함께 HTML 요소로 전환.

우선순위 : 인라인스타일 > # > . > tag

---

# 형 변환 메소드

## 암시적형변환
스크립트가 사용자 동의 없이 자동으로 데이터 형태를 결정하는 형태
ex) window.prompt();
    <input type="text" value="abc" name="user_id"> 등
    console.log(typeof(객체명))을 통해 형태 확인하기.
## 명시적형변환
개발자가 직접 데이터타입을 스크립트로 명령하여 강제로 변환하는 형변환 작업
ex) string() / **number()**

---

# DOM 이벤트 처리기

### Event?
사용자의 행동에 따른 웹/앱이 특정 결과를 실행하는 행위
Event 앞에 on을 붙이면 이벤트 리스너가 된다 ex) onclick

* 마우스 이벤트
on+ **click** : 특정 요소를 마우스로 클릭했을 때 이벤트 발생
    mouseover : 특정 요소에 마우스 포인터가 올라갈 때 이벤트 발생
    mouseout : 특정 요소에서 마우스 포인터가 이탈할 때
    mouseup : 특정 요소를 마우스로 눌렀다가 떼었을 경우
    mousemove : 특정요소에서 마우스 포인터를 움직일 경우

* 키보드 이벤트
on+ keydown -> 특정 키를 누를 경우
    keyup -> 특정 키를 누르고 뗀 경우

* 기타 이벤트
on+ focus-> 특정 요소에 포커스를 줄 경우 이벤트 발생
    blur -> 특정 요소에서 포커스가 벗어난 경우.
    submit -> submit 버튼을 클릭할 경우
    reset -> reset 버튼을 클릭할 경우
    load -> 페이지 로딩이 완료될 경우.

    이러한 이벤트로 실행되는 함수를 콜백함수[Call back Function] 이라고 부른다.

---

# 콜백 함수 [Callback]
1. 고객(사용자)이 커피 주문 요청
2. 점원(함수)이 커피를 제조하고 손님에게 건네줌(call back)

순서 : 고객 요청 -> 점원 확인
콜백 : 고객 확인 <- 점원이 고객 호출

ex) DOM요소(document)addEventListner(이벤트명, 실행함수명, 옵션)

특정 이벤트 발생 시 해당 이벤트 처리 루틴 = 콜백함수
* 이벤트명  : 자바 스크립트에서 발생하는 이벤트명
* 실행함수명 : 이벤트 발생 시 실행할 함수명
* 옵션 : 생략 가능한 요소. 자식과 부모요소에서 발생하는 버블링을 제어하는 옵션.

---

## 콜백 함수 정리
### 매개변수없는 콜백함수 호출
* `DOM.addEventLister('이벤트', 콜백함수호출)`
* `function 콜백함수명(){return 반복실행}`

### 매개변수가 있을경우
* `DOM.addEventLister('이벤트', ()=> 콜백함수호출(매개변수 입력))`
* `DOM.addEventLister('이벤트', function(){콜백함수(매개변수)})`
* `function 콜백함수(매개변수){return 반복실행}`

### 매개변수가 있는 콜백함수 호출(클로저활용)
* `DOM.addEventLister('이벤트', 콜백함수호출)`
* `function 콜백함수(매개변수){return function(){반복실행}}`

요소 속성 값 읽고 쓰기
요소명.속성명
<a href="https://naver.com" id="link" target="_blank">naver</a>

## innerHTML
요소의 HTML 콘텐츠 읽기, 수정, 삭제 속성
HTML태그를 포함하여 처리.

## innerTEXT
요소의 텍스트 읽기, 수정, 삭제 속성
HTML 태그는 무시하고 텍스트만 반환.

## textContent
요소의 텍스트 읽기, 수정, 삭제 속성
innerText보다 빠른 수행 가능.
HTML태그는 무시하고 텍스트만 반환.

---

sass 파일 관리 & sass를 이용한 반응형 웹

css: @media screen and (max-width:1200px){
    main {}
    main h1 {}
}

scss @media screen and (max-width:1200px){
    main{
        h1{

        }
    }
}

어렵지 않다.

---

## SASS 파일 관리

### main.scss
//@use './common.scss' as c;
//@use './index.scss' as c;
//@use './footer.scss' as c;

### common.scss
$변수명 : 등록값;
$변수명 : 등록값;

@mixin 그룹변수명 { 반복속성 : 값 ; 반복 속성 : 값}
@mixin 그룹변수명 { 반복속성 : 값 ; 반복 속성 : 값}

---

# 이벤트 객체
* 사용자가 DOM과 관련된 이벤트 발생 시 이벤트 관련정보가 생성됨.
이 정보를 'Event Object / 이벤트 객체' 라고 칭한다.
ex) 마우스 이벤트 발생 시 마우스 위치 정보
ex) 키보드 이벤트 발생 시 어떤 키를 눌렀을 지에 대한 정보 등

## 이벤트 객체의 자주 사용하는 속성 및 함수
1. currentTarget : 현재 이벤트 처리중인 요소, 이벤트 핸들러 내부 this와 동일
2. preventDefault() : 이벤트의 기본 동작 취소
3. target : 이벤트 실제 및 적용 요소
4. type : 발생하는 이벤트 타입
5. client X, Client Y : 마우스 이벤트 발생 시 클릭한 커서의 상대 좌표

---

# this
함수가 호출될 시 해당 함수를 소유한 객체를 참조하는 키워드

* 익명함수는 **이벤트를 호출하는 객체** 에 따라 this가 결정됨
ex) input이 객체면 this=input
ex) button이 객체면 this=button

* 화살표 함수는 상위 스코프의 this를 사용함
ex) 전역 스코프라면 this는 window객체를 인식.
ex) 위와 같은 문제로 화살표함수는 this를 사용하지 않음.

## 익명함수의 this
const aTag=document.querySelector('click',function()){
    console.log(this); 호출하는 객체에 따라 this결정. 여기서 this는 aTag임
}

## 화살표 함수의 this

---

# Boolean
### 참(true) 또는 거짓(False) 두가지 값 중 하나의 데이터 형식 조건문, 논리연산자, 논리적 판단 등에 사용함.

ex) 날씨가 좋은가?
true -> 산책을 간다.
false -> 방콕을 한다.

ex) 날씨가 추운가?
true -> 체육관에서 3대운동 실시
false -> 집에서 맨몸운동 실시

---

# false, falsy & true, truthy
### False로 평가되는 값 -> falsy / True로 평가되는 값 -> truthy
거짓으로 평가되는 값
-> false, null, undefined, NaN, 0, " "(빈 문자열)

참으로 평가되는 값
-> 거짓을 제외한 나머지 값
-> 빈 배열, 빈 객체는 true []//빈 배열, {}//빈 객체

Boolean()
불린 함수를 사용했을 때, Falsy값들은 False로 truthy값들은 true로 리턴됨.

숫자로 표현할 수 있냐 없냐에 따라, true, false 값이 결정되기도 함.

---

# 비교연산자, 일치 연산자.

'='을 2개쓰냐, 3개쓰느냐에 따라 의미가 달라진다
x=y -> 같다
x==y-> x와 y의 값이 같다. (절대값만)
x===y -> X와 Y의 데이터 타입이 모두 같다. (엄격)

# 부등 연산자
x != y
ex) x와 y의 값이 같지않다.
ex) 5 != "5" -> false
// 값 자체는 같기 때문에 해당 공식이 성립하지 않으므로 false가 되고

x !== y
ex) x와 y의 값과 데이터 타입이 모두 다르다.
ex) 5 !== "5" -> true
// x와 y의 값은 같으나, 데이터 타입은 Number와 String으로 다르므로 공식이 성립하기 때문에 true이다.

---

# > 와 <, 크기 비교 연산자.

x < y -> x가 y보다 작다. ex) 3 < 5 => true
x > y -> x가 y보다 크다. ex) 7 > 10 => false
x >= y -> x가 y보다 크거나 같다. ex) 10 >= 10 => true
x <= y -> x가 y보다 작거나 같다. ex) 10 =< 12 => false

---

# 논리 연산자
### 논리적인 조건을 결합하거나 변경하는데 사용하는 연산자

* AND(&&) 양쪽 피연산자가 모두 참일 때, 모두 참.
ex) x=y&&y=z //=>
* or(||) 양쪽 피연산자 중 하나라도 참이면 결과는 참.
ex) x=y||y=z //=>
* Not(!) 피연산자의 논리 값을 반전함. 참이면 거짓으로, 거짓이면 참으로 변환하는 청개구리.
ex) x!

* 자바스크립트의 논리연산자는 무조건 결과값으로 true나 false가 못나오는 상황이라면,
양쪽 피연산자가 값들 중 어느 한쪽을 선택하여 출력하는 방식으로 동작한다.

논리 연산자 and (&&)
ex) "A" && null => falsy => null
ex) null && "A" => falsy => null
ex) "A" && ""B"" => truty => "B"

논리 연산자 or (||)
ex) "A" || null => truty => "A"
ex) null || "A" => truty => "A"
ex) "A" | ""B"" => truty => "A"

논리 연산자 Not (!)
!"A" => false => "A"는 데이터 값이 있어 true이나, !로 반전시켜 false가 된다.
! "0" => true => "0"는 데이터 값이 0으로 false이나, !로 반전시켜 true가 된다.
! [] => false =>: []는 인덱스 배열로, 인덱스 길이는 0, 이지만 인덱스 슬롯 값이 삽입될 수 있으므로 true이다. 여기서 !로 반전시켜 false가 된다.

---

# 조건문 if

**조건문==분기문 (분기점)**
어떤 특정 조건에 따라서 수행 루트를 분기점으로 나누어 처리하는 문법 (선택지)

'내가 만약 로또 1등에 당첨된다면...'

## 조건 if
중진 조건에 따라 결과가 참/거짓으로 나뉠 때 참에 대한 결과를 실행
ex) 날씨가 맑은가? =참일경우=> 산책을 간다
ex) if(날씨가 맑다) =참일경우=> 산책 ㄱㄱ


## if문 사용방법

if(수행조건){하고싶은 일}
1. if괄호 안에 '수행조건' 작성
2. 수행 조건 만족 시 결과 true리턴, '수행하고 싶은 일' 수행
불만족 시 false로 리턴

if(20 > 10) {console.log('20은 10보다 큽니다.)}
1. if괄호 안에 '수행조건' 작성
2. 수행 조건 만족 시 결과 true리턴, '수행하고 싶은 일' 수행
불만족 시 false로 리턴

---

# if~else

## if문을 통해 수행 조건을 만족하면 -> 작업 실행
그러나 만족하지 않으면?
* 수행조건을 만족하지 않은 경우에도 특정처리를 해주어야 명확한 로직 구성이 가능하다.

ex) A동작 -> 참인 경우 동작
ex) B동작 -> 거짓인 경우 동작

if문으로 수행동작이 '참'인 경우 A동작,
else문으로 수행동작이 '거짓'인 경우 B동작이 이루어지도록 로직을 작성.

ex)
if(수행조건){
    수행조건 만족 시 수행
    else{
        수행조건 불충족시 수행
    }
}

1. if문의 괄호안에 '수행조건' 작성
2. 만족 시 그 결과를 true로 return, '수행조건 만족 시 수행' 이행
3. 수행조건 불충족 시 false를 return, else 실행
4. else블록 안 '수행 조건 불충족시 수행' 이행

---

## 로컬 스토리지 활용 (javascript)
* 활용 예 : 로그인 유무에 따라 다르게 나오는 장바구니/구매페이지/카페/메일 등
* 로컬 스토리지 : 브라우저에 데이터를 영구적으로 저장하는 방법
* 로컬스토리지 종류 : localStorage, sessionStorage

### localStorage
* 페이지를 새로고침하거나 브라우저를 닫아도 데이터 유지
* localStorage.setItem('속성', '값')
* localStorage.getItem('속성')

### sessionStorage
* 브라우저가 닫히면 데이터 자동삭제 (휘발성)
* sessionStorage.setItem('속성', '값')
* sessionStorage.getItem('속성')